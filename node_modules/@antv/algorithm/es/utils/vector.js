/**
 * 向量运算
 */
import { clone } from '@antv/util';

var Vector =
/** @class */
function () {
  function Vector(arr) {
    this.arr = arr;
  }

  Vector.prototype.add = function (otherVector) {
    var _a;

    var otherArr = otherVector.arr;

    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
      return new Vector(otherArr);
    }

    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return new Vector(this.arr);
    }

    if (this.arr.length === otherArr.length) {
      var res = [];

      for (var key in this.arr) {
        res[key] = this.arr[key] + otherArr[key];
      }

      return new Vector(res);
    }
  };

  Vector.prototype.subtract = function (otherVector) {
    var _a;

    var otherArr = otherVector.arr;

    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
      return new Vector(otherArr);
    }

    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return new Vector(this.arr);
    }

    if (this.arr.length === otherArr.length) {
      var res = [];

      for (var key in this.arr) {
        res[key] = this.arr[key] - otherArr[key];
      }

      return new Vector(res);
    }
  };

  Vector.prototype.avg = function (length) {
    var res = [];

    for (var key in this.arr) {
      res[key] = this.arr[key] / length;
    }

    return new Vector(res);
  };

  Vector.prototype.negate = function () {
    var res = [];

    for (var key in this.arr) {
      res[key] = -this.arr[key];
    }

    return new Vector(res);
  }; // 平方欧式距离


  Vector.prototype.squareEuclideanDistance = function (otherVector) {
    var _a;

    var otherArr = otherVector.arr;

    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return 0;
    }

    if (this.arr.length === otherArr.length) {
      var res = 0;

      for (var key in this.arr) {
        res += Math.pow(this.arr[key] - otherVector.arr[key], 2);
      }

      return res;
    }
  }; // 归一化处理


  Vector.prototype.normalize = function () {
    var res = [];
    var cloneArr = clone(this.arr);
    cloneArr.sort(function (a, b) {
      return a - b;
    });
    var max = cloneArr[cloneArr.length - 1];
    var min = cloneArr[0];

    for (var key in this.arr) {
      res[key] = (this.arr[key] - min) / (max - min);
    }

    return new Vector(res);
  }; // 2范数 or 模长


  Vector.prototype.norm2 = function () {
    var _a;

    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
      return 0;
    }

    var res = 0;

    for (var key in this.arr) {
      res += Math.pow(this.arr[key], 2);
    }

    return Math.sqrt(res);
  }; // 两个向量的点积


  Vector.prototype.dot = function (otherVector) {
    var _a;

    var otherArr = otherVector.arr;

    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return 0;
    }

    if (this.arr.length === otherArr.length) {
      var res = 0;

      for (var key in this.arr) {
        res += this.arr[key] * otherVector.arr[key];
      }

      return res;
    }
  };

  return Vector;
}();

export default Vector;